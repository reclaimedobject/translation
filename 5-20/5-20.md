## Introduction

2019년 8월, 약 1년쯤 전 [Ultimate Go Study Guide](https://github.com/hoanhan101/ultimate-go) 라는 프로젝트를 GitHub 에 공유했습니다. 그리고 놀랍게도, 커뮤니티로부터 많은 관심을 받았으며 2020년 8월 기준으로 12K star, 900 fork 를 넘어섭습니다. 20 여분의 contributor 분들의 도움이 컸습니다.

프로젝트는 제가 [Ardan Lab's Ultimate Go course](https://www.oreilly.com/library/view/ultimate-go-programming/9780134757476/) 를 공부하면서

A year ago, in August 2019, I shared one of my projects called [Ultimate Go Study Guide on GitHub](https://github.com/hoanhan101/ultimate-go), and surprisingly, it got a lot of attention from the community. Fast forward to August 2020, it now has over 12K stars, 900 forks with the help of more than 20 contributors.

The project is a collection of my notes while learning Go programming language from [Ardan Lab's Ultimate Go course](https://www.oreilly.com/library/view/ultimate-go-programming/9780134757476/). Honestly, I couldn’t thank Bill Kennedy and the Ardan Labs team enough for open-sourcing this wonderful material. They’ve done
such great jobs putting together their knowledge, insights into their courses, and making them available to the public.

Different people have different learning styles. For me, I learn best by doing and walking through examples. That said, I take notes carefully, comment directly on the source code to make sure that I understand every single line of code as I am reading and also be mindful of the theories behind the scene.

As Ultimate Go Study Guide keeps growing, there’s one issue that keeps coming up. That’s about the format of the project. Specifically, many people have requested
an ebook version where the content is more streamlined and they can read it at their convenience.

So, here comes The Ultimate Go Study Guide eBook version. For the last 3 months or so, I have spent most of my free time putting together everything from Ultimate Go
Study Guide into a 200-page book. Other than all the good stuff from Ultimate Go, two new and better things in this version are:

- Follow-along code input and output.
- Diagrams.

Hope it makes your journey of learning Go a bit easier. And again, thank you all for your support. I really appreciate it.

Happy reading!

## Language Mechanics

### Syntax

#### Variable

##### Built-in types

Type provides integrity and readability by asking 2 questions:

- What is the amount of memory that we allocate? (e.g. 32-bit, 64-bit)
- What does that memory represent? (e.g. int, uint, bool,..)

Type can be specific such as int32 or int64. For example,

- uint8 contains a base 10 number using one byte of memory
- int32 contains a base 10 number using 4 bytes of memory.

When we declare a type without being very specific, such as uint or int, it gets mapped based on the architecture we are building the code against. On a 64-bit OS, int will map to int64. Similarly, on a 32 bit OS, it becomes int32.

**Word size**

The word size is the number of bytes in a word, which matches our address size. For example, in 64-bit architecture, the word size is 64 bit (8 bytes), address
size is 64 bit then our integer should be 64 bit.

##### Zero value concept

Every single value we create must be initialized. If we don't specify it, it will be set to the zero value. The entire allocation of memory, we reset that bit to 0.

| Type           | Zero value |
| -------------- | ---------- |
| Boolean        | false      |
| Integer        | 0          |
| Floating Point | 0          |
| Complex        | 0i         |
| String         | ""         |
| Pointer        | nil        |

##### Declare and initialize

var is the only guarantee to initialize a zero value for a type.

```go
var a int
var b string
var c float64
var d bool
fmt.Printf( "var a int \t %T [%v]\n" , a, a)
fmt.Printf( "var b string \t %T [%v]\n" , b, b)
fmt.Printf( "var c float64 \t %T [%v]\n" , c, c)
fmt.Printf( "var d bool \t %T [%v]\n\n" , d, d)
var a
```

```
var a int int [0]
var b string string []
var c float64 float64 [0]
var d bool bool [false]
```

##### Conversion vs casting

#### Struct

##### Declare and initialize

##### Name type vs anonymous type

#### Pointer

##### Everything is about pass by value

##### Pass by value

#### Escape analysis

#### Function

#### Constant

##### Declare and initialize

##### iota
